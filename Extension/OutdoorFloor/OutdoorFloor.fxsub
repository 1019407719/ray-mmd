#define LIGHTINGMODEL_NORMAL         0
#define LIGHTINGMODEL_TRANSMITTANCE  1
#define LIGHTINGMODEL_EMISSIVE       2

#define SUBSURFACESCATTERING_MARBLE 0
#define SUBSURFACESCATTERING_SKIN   1

#define MIDPOINT_8_BIT (127.0f / 255.0f)
#define MAX_FRACTIONAL_8_BIT (255.0f / 256.0f)
#define TWO_BITS_EXTRACTION_FACTOR  (3.0f + MAX_FRACTIONAL_8_BIT)
#define InvPIE 0.318309886142f
#define PI_2 (3.141592654f * 2.0)

float3 CameraPosition : POSITION  < string Object = "Camera"; >;
float2 ViewportSize : VIEWPORTPIXELSIZE;

float4x4 matView  : VIEW;
float4x4 matViewInverse : VIEWINVERSE;
float4x4 matViewProject  : VIEWPROJECTION;

float3 LightSpecular  : SPECULAR  < string Object = "Light"; >;
float3 LightDirection : DIRECTION < string Object = "Light"; >;

float mEnvRotateX : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvRotateX"; >;
float mEnvRotateY : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvRotateY"; >;
float mEnvRotateZ : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvRotateZ"; >;
float mEnvLightP : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvLight+";>;
float mEnvLightM : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvLight-";>;
float mEnvSpecLightP : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvSpecLight+";>;
float mEnvSpecLightM : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "EnvSpecLight-";>;
float mDirectLightP : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "DirectLight+"; >;
float mDirectLightM : CONTROLOBJECT < string name="ray_controller.pmx"; string item = "DirectLight-"; >;

float3x3 makeRotate(float eulerX, float eulerY, float eulerZ)
{
    float sj, cj, si, ci, sh, ch;

    sincos(eulerX, si, ci);
    sincos(eulerY, sj, cj);
    sincos(eulerZ, sh, ch);

    float cc = ci * ch;
    float cs = ci * sh;
    float sc = si * ch;
    float ss = si * sh;

    float a1 = cj * ch;
    float a2 = sj * sc - cs;
    float a3 = sj * cc + ss;

    float b1 = cj * sh;
    float b2 = sj * ss + cc;
    float b3 = sj * cs - sc;

    float c1 = -sj;
    float c2 = cj * si;
    float c3 = cj * ci;
    
    float3x3 rotate;
    rotate[0] = float3(a1, a2, a3);
    rotate[1] = float3(b1, b2, b3);
    rotate[2] = float3(c1, c2, c3);
    
    return rotate;
}

static float rotateX = mEnvRotateX * PI_2;
static float rotateY = mEnvRotateY * PI_2;
static float rotateZ = mEnvRotateZ * PI_2;
static float3x3 rotate = makeRotate(rotateX, rotateY, rotateZ);
static float2 ViewportOffset = float2(0.5f, 0.5f) / ViewportSize;
static float2 ViewportOffset2 = float2(1.0f, 1.0f) / ViewportSize;

shared texture MaterialMap: OFFSCREENRENDERTARGET;
shared texture Gbuffer2RT: RENDERCOLORTARGET;
shared texture Gbuffer3RT: RENDERCOLORTARGET;
shared texture Gbuffer4RT: RENDERCOLORTARGET;
shared texture Gbuffer5RT: RENDERCOLORTARGET;
shared texture Gbuffer6RT: RENDERCOLORTARGET;
shared texture Gbuffer7RT: RENDERCOLORTARGET;
shared texture Gbuffer8RT: RENDERCOLORTARGET;

texture IBLDiffMap<string ResourceName=IBL_DIFF_MAP_FILE;>; 
sampler IBLDiffMapSamp = sampler_state
{
    texture = IBLDiffMap;
    MINFILTER = LINEAR; MAGFILTER = LINEAR; ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};

texture IBLSpecMap<string ResourceName=IBL_SPEC_MAP_FILE;>; 
sampler IBLSpecMapSamp = sampler_state
{
    texture = IBLSpecMap;
    MINFILTER = LINEAR; MAGFILTER = LINEAR; ADDRESSU = CLAMP; ADDRESSV = CLAMP;
};

texture OutdoorMap : OFFSCREENRENDERTARGET <
    string Description = "OffScreen RenderTarget for OutdoorFloor";
    string Format = "A16B16G16R16F";
    float2 ViewPortRatio = {1.0, 1.0};
    float4 ClearColor = { 0, 0, 0, 0.5 };
    float ClearDepth = 1.0;
    int Miplevels = 0;
    bool AntiAlias = false;
    string DefaultEffect = 
        "*controller.pmx = hide;"
        "*.pmd = OutdoorObject.fx;"
        "*.pmx = OutdoorObject.fx;"
        "* = hide;" ;
>;

sampler OutdoorMapSamp = sampler_state 
{
    texture = <OutdoorMap>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = CLAMP;
    AddressV = CLAMP;
};

sampler Gbuffer1Map = sampler_state {
    texture = <MaterialMap>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer2Map = sampler_state {
    texture = <Gbuffer2RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer3Map = sampler_state {
    texture = <Gbuffer3RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer4Map = sampler_state {
    texture = <Gbuffer4RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer5Map = sampler_state {
    texture = <Gbuffer5RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer6Map = sampler_state {
    texture = <Gbuffer6RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer7Map = sampler_state {
    texture = <Gbuffer7RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};
sampler Gbuffer8Map = sampler_state {
    texture = <Gbuffer8RT>;
    MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
    AddressU  = CLAMP; AddressV  = CLAMP;
};

struct MaterialParam
{
    float3 normal;
    float3 albedo;
    float3 specular;
    float3 transmittance;
    float3 emissive;
    float emissiveIntensity;
    float smoothness;
    float index;
    float alpha;
    float linearDepth;
    int lightModel;
};

float3 ycbcr2rgb(float3 YCbCr)
{
    YCbCr = float3(YCbCr.x, YCbCr.y / MIDPOINT_8_BIT - 1, YCbCr.z / MIDPOINT_8_BIT - 1);
    float R = YCbCr.x + 1.402 * YCbCr.z;
    float G = dot(float3( 1, -0.3441, -0.7141 ), YCbCr.xyz );
    float B = YCbCr.x + 1.772 * YCbCr.y;
    return float3(R, G, B);
}

float3 linear2srgb(float3 srgb)
{
    const float ALPHA = 0.055f;
    return srgb < 0.0031308f ? 12.92f * srgb : (1 + ALPHA) * pow(srgb, 1.0f / 2.4f) - ALPHA;
}

float3 srgb2linear(float3 rgb)
{
    const float ALPHA = 0.055f;
    return rgb < 0.04045f ? rgb / 12.92f : pow((rgb + ALPHA) / (1 + ALPHA), 2.4f);
}

float SmoothnessToRoughness(float smoothness)
{
    return (1.0f - smoothness) * (1.0f - smoothness);
}

float2 PosToCoord(float2 position)
{
    position = position * 0.5 + 0.5;
    return float2(position.x, 1 - position.y);
}

float2 ComputeSphereCoord(float3 normal)
{
    float2 coord = float2(1 - (atan2(normal.x, normal.z) * InvPIE * 0.5f + 0.5f), acos(normal.y) * InvPIE);
    return coord;
}

float3 DecodeRGBM(in float4 rgbm)
{
    return 6 * rgbm.rgb * rgbm.a;
}

float3 DecodePack2Normal(float2 enc)
{
    float2 fenc = enc.xy * 4 - 2;
    float f = dot(fenc,fenc);
    float g = sqrt(1-f/4);
    float3 n;
    n.xy = fenc*g;
    n.z = 1-f/2;
    return n;
}

float3 DecodePack3Normal(float3 enc)
{
    float nz = floor(enc.z * 255) / 16;
    enc.xy += float2(floor(nz) / 16, frac(nz)) / 255;
    float2 fenc = enc.xy * 4 - 2;
    float f = dot(fenc, fenc);
    float g = sqrt(1 - f / 4);
    float3 normal;
    normal.xy = fenc * g;
    normal.z = f / 2 - 1;
    return normalize(normal);
}

void DecodeGbuffer(sampler source, float2 coord, float4 screenPosition, float2 offset, float mip, out float3 color, out float3 normal)
{
    float4 packed = tex2Dlod(source, float4(coord, 0, mip));
    
    float4 env2 = tex2Dlod(source, float4(coord + float2(offset.x, 0.0), 0, mip));
    float4 env3 = tex2Dlod(source, float4(coord - float2(offset.x, 0.0), 0, mip));
    float4 env4 = tex2Dlod(source, float4(coord + float2(0.0, offset.y), 0, mip));
    float4 env5 = tex2Dlod(source, float4(coord - float2(0.0, offset.y), 0, mip));
    
    env2.rg = (env2.rg + env3.rg + env4.rg + env5.rg) * 0.25;
    env2.ba = (env2.ba + env3.ba + env4.ba + env5.ba) * 0.25;

    bool pattern = (fmod(screenPosition.x, 2.0) == fmod(screenPosition.y, 2.0));
    
    color = (pattern) ? float3(packed.ba, env2.a) : float3(packed.b, env2.a, packed.a);
    color = ycbcr2rgb(color);
    
    normal = DecodePack2Normal(packed.xy);
}

void DecodeGbuffer(float4 buffer1, float4 buffer2, float4 buffer3, float4 buffer4, out MaterialParam material)
{
    material.lightModel = (int)floor(buffer3.w * TWO_BITS_EXTRACTION_FACTOR);

    material.albedo = buffer1.xyz;
    material.smoothness = buffer1.w;

    material.normal = DecodePack3Normal(buffer2.xyz);
    material.index = buffer2.w * TWO_BITS_EXTRACTION_FACTOR;
    material.transmittance = 0;
    material.emissive = 0;
    material.emissiveIntensity = 0;
    
    material.linearDepth = buffer4.x;
    material.alpha = buffer4.w;
    
    if (material.lightModel == LIGHTINGMODEL_TRANSMITTANCE)
    {
        material.specular = buffer3.xxx;
        material.transmittance = ycbcr2rgb(float3(frac(buffer3.w * TWO_BITS_EXTRACTION_FACTOR), buffer3.yz));
    }
    else if (material.lightModel == LIGHTINGMODEL_EMISSIVE)
    {
        material.specular = buffer3.xxx;
        material.emissive = ycbcr2rgb(float3(frac(buffer3.w * TWO_BITS_EXTRACTION_FACTOR), buffer3.yz));
        material.emissiveIntensity = buffer4.y;
    }
    else
    {
        material.specular = ycbcr2rgb(buffer3.xyz);
    }
}

float3 EnvironmentSpecularUnreal4(float3 N, float3 V, float roughness, float3 specular)
{
    float4 c0 = float4(-1, -0.0275, -0.572, 0.022);
    float4 c1 = float4(1, 0.0425, 1.04, -0.04);
    float4 r = roughness * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * dot(N, V))) * r.x + r.y;
    float2 AB = float2(-1.04, 1.04) * a004 + r.zw;
    return specular * AB.x + AB.y;
}

float EnvironmentMip(float roughness, int miplevel)
{
    return sqrt(roughness) * miplevel;
}

float3 EnvironmentReflect(float3 normal, float3 view)
{
    return reflect(-view, normal);
}

void ShadingMaterial(float3 V, MaterialParam material, out float3 diffuse, out float3 specular)
{
    float3 worldView = V;
    float3 worldNormal = mul(material.normal, (float3x3)matViewInverse);
    float3 worldReflect = EnvironmentReflect(worldNormal, worldView);
    
    float roughness = SmoothnessToRoughness(material.smoothness);
    float mipLayer = EnvironmentMip(roughness, IBL_MIPMAP_LEVEL);

    float3 R = mul(rotate, worldReflect);
    float3 N = mul(rotate, worldNormal);

    float4 prefilteredDiffuse = tex2D(IBLDiffMapSamp, ComputeSphereCoord(N));
    float4 prefilteredSpeculr = tex2Dlod(IBLSpecMapSamp, float4(ComputeSphereCoord(R), 0, mipLayer));

#if IBL_ENABLE_GAMMA_CORRECTION
    prefilteredDiffuse.rgb = srgb2linear(prefilteredDiffuse.rgb);
    prefilteredSpeculr.rgb = srgb2linear(prefilteredSpeculr.rgb);
#endif

#if IBL_HDR_ENABLE
    prefilteredDiffuse.rgb = DecodeRGBM(prefilteredDiffuse);
    prefilteredSpeculr.rgb = DecodeRGBM(prefilteredSpeculr);
#endif

    diffuse = prefilteredDiffuse.rgb * material.albedo;
    specular = prefilteredSpeculr.rgb * EnvironmentSpecularUnreal4(worldNormal, worldView, roughness, material.specular);
    specular *= step(0, material.specular - 1e-5);

    diffuse *= (1 + mEnvLightP * 5 - mEnvLightM);
    specular *= (1 + mEnvSpecLightP * 5 - mEnvSpecLightM);
}

void OutdoorFloorVS(
    in float4 Position : POSITION, 
    out float4 oTexcoord : TEXCOORD0,
    out float3 oViewdir  : TEXCOORD1,
    out float4 oPosition : POSITION)
{
    oViewdir = normalize(CameraPosition.rgb - Position.rgb);
    oTexcoord = oPosition = mul(Position, matViewProject);
}

float4 OutdoorFloorPS(
    in float4 texcoord : TEXCOORD0,
    in float3 viewdir  : TEXCOORD1,
    in float4 screenPosition : SV_Position) : COLOR
{
    float2 mirror = texcoord.xy / texcoord.w;
    mirror = 1 - (mirror * 0.5 + 0.5);
    mirror += ViewportOffset;
    
    float2 screen = texcoord.xy / texcoord.w;
    screen = PosToCoord(screen);
    screen += ViewportOffset;
    
    float3 V = normalize(viewdir);
    float3 L = mul(-LightDirection, (float3x3)matView);

    float4 MRT0 = tex2D(Gbuffer1Map, screen);
    float4 MRT1 = tex2D(Gbuffer2Map, screen);
    float4 MRT2 = tex2D(Gbuffer3Map, screen);
    float4 MRT3 = tex2D(Gbuffer4Map, screen);

    MaterialParam material;
    DecodeGbuffer(MRT0, MRT1, MRT2, MRT3, material);

    float roughness = SmoothnessToRoughness(material.smoothness);
    float miplevel = EnvironmentMip(roughness, 6);

    float3 normal;
    float3 albedo;
    DecodeGbuffer(OutdoorMapSamp, mirror, screenPosition, ViewportOffset2, miplevel, albedo, normal);
    
    MaterialParam outdoorMaterial;
    outdoorMaterial.albedo = albedo;
    outdoorMaterial.normal = normal;
    outdoorMaterial.specular = 0.04;
    outdoorMaterial.transmittance = 0;
    outdoorMaterial.emissiveIntensity = 0;
    outdoorMaterial.emissive = 0;
    outdoorMaterial.smoothness = 0.1;
    
    float3 diffuse, specular;
    ShadingMaterial(V, outdoorMaterial, diffuse, specular);
        
    float3 direction = saturate(dot(normal, L));
    direction *= outdoorMaterial.albedo * LightSpecular;
    direction *= (1 + mDirectLightP * 10 - mDirectLightM);
    
    float3 lighting = diffuse + specular;
    lighting += direction;
    lighting *= EnvironmentSpecularUnreal4(material.normal, V, roughness, max(1, material.specular));
    
    return float4(linear2srgb(lighting), -1.0);
}

#define OBJECT_TEC(name, mmdpass) \
    technique name < string MMDPass = mmdpass;\
    > { \
        pass DrawObject { \
            AlphaTestEnable = false; AlphaBlendEnable = false;\
            VertexShader = compile vs_3_0 OutdoorFloorVS();\
            PixelShader  = compile ps_3_0 OutdoorFloorPS();\
        } \
    }

OBJECT_TEC(MainTec0, "object")
OBJECT_TEC(MainTecBS0, "object_ss")

technique EdgeTec < string MMDPass = "edge"; > {}
technique ShadowTech < string MMDPass = "shadow";  > {}
technique ZplotTec < string MMDPass = "zplot"; > {}